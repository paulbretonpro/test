import { defineNuxtModule, createResolver, addPlugin, addImportsDir, addServerImportsDir } from '@nuxt/kit';
import { fileURLToPath } from 'url';
import defu from 'defu';
import prompts from 'prompts';
import { execa } from 'execa';
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import chalk from 'chalk';

async function executeRequiredPrompts({
  promptForMigrate = true,
  promptForPrismaStudio = true
}) {
  const options = [];
  if (promptForMigrate) {
    options.push({
      type: "confirm",
      name: "promptForPrismaMigrate" /* PROMPT_MIGRATE */,
      message: "Do you want to migrate database changes to your database?",
      initial: true
    });
  }
  if (promptForPrismaStudio) {
    options.push({
      type: "confirm",
      name: "promptForInstallingStudio" /* PROMPT_STUDIO */,
      message: "Do you want to view and edit your data by installing Prisma Studio in Nuxt DevTools?",
      initial: true
    });
  }
  if (options.length === 0) {
    return null;
  }
  try {
    const answers = await prompts(options);
    const result = {
      ["promptForPrismaMigrate" /* PROMPT_MIGRATE */]: answers["promptForPrismaMigrate" /* PROMPT_MIGRATE */] ?? false,
      ["promptForInstallingStudio" /* PROMPT_STUDIO */]: answers["promptForInstallingStudio" /* PROMPT_STUDIO */] ?? false
    };
    return result;
  } catch (error) {
    console.error("Error during prompts execution:", error);
    return null;
  }
}

function detectPackageManager() {
  if (existsSync("package-lock.json")) {
    return "npm";
  }
  if (existsSync("yarn.lock")) {
    return "yarn";
  }
  if (existsSync("pnpm-lock.yaml")) {
    return "pnpm";
  }
  if (existsSync("bun.lockb")) {
    return "bun";
  }
  return "npm";
}
const installingPrismaCLIWithPM = () => {
  const pm = detectPackageManager();
  switch (pm) {
    case "npm": {
      return {
        pm,
        command: ["install", "prisma", "--save-dev"]
      };
    }
    case "pnpm": {
      return {
        pm,
        command: ["add", "-D", "prisma"]
      };
    }
    case "yarn": {
      return {
        pm,
        command: ["add", "-D", "prisma"]
      };
    }
    case "bun": {
      return {
        pm,
        command: ["add", "prisma", "--dev"]
      };
    }
    default: {
      return {
        pm: "npm",
        command: ["install", "prisma", "--save-dev"]
      };
    }
  }
};
const installingPrismaClientWithPM = () => {
  const pm = detectPackageManager();
  switch (pm) {
    case "npm": {
      return {
        pm,
        command: ["install", "@prisma/client", "--save-dev"]
      };
    }
    case "pnpm": {
      return {
        pm,
        command: ["add", "-D", "@prisma/client"]
      };
    }
    case "yarn": {
      return {
        pm,
        command: ["add", "-D", "@prisma/client"]
      };
    }
    case "bun": {
      return {
        pm,
        command: ["add", "@prisma/client", "--dev"]
      };
    }
    default: {
      return {
        pm: "npm",
        command: ["install", "@prisma/client", "--save-dev"]
      };
    }
  }
};

function logSuccess(message) {
  console.log(chalk.green(`\u2714 ${message}`));
}
function logError(message) {
  console.error(chalk.red(`\u2718 ${message}`));
}
function log(message) {
  console.log(message);
}
const PREDEFINED_LOG_MESSAGES = {
  isPrismaCLIinstalled: {
    yes: `Prisma CLI is already installed.`,
    no: `Prisma CLI is not installed.`
  },
  installPrismaCLI: {
    action: "Installing Prisma CLI...",
    yes: `Successfully installed "Prisma CLI.`,
    no: `Failed to install Prisma CLI.`
  },
  checkIfPrismaSchemaExists: {
    yes: "Prisma schema file exists.",
    no: "Prisma schema file does not exist."
  },
  initPrisma: {
    action: "Initializing Prisma project...\n",
    error: "Failed to initialize Prisma project."
  },
  checkIfMigrationsFolderExists: {
    success: "Database migrations folder exists.",
    error: "Database migrations folder does not exist."
  },
  writeToSchema: {
    errorReadingFile: "Error reading existing schema file.",
    failedToWrite: "Failed to write models to Prisma schema."
  },
  runMigration: {
    action: "Migrating database schema...\n",
    success: "Created User and Post tables in the database.",
    error: "Failed to run Prisma migration."
  },
  formatSchema: {
    action: "Formatting Prisma schema...\n",
    success: "Successfully formatted Prisma schema.",
    error: "Failed to format Prisma schema file."
  },
  generatePrismaClient: {
    action: "Generating Prisma client...\n",
    prismaClientInstallationError: "Failed to install Prisma Client.\n",
    success: "Prisma Client successfully generated!",
    error: "Failed to generate Prisma Client.\n"
  },
  installStudio: {
    action: "Starting Prisma Studio...\n",
    success: `Prisma Studio installed.` + chalk.white(
      `
After clicking ${chalk.bold("Get Started")} in Nuxt DevTools, click on the ${chalk.bold("three dots (\uFE19)")} in the lower left-hand side to reveal additional tabs.
Locate the Prisma logo to open Prisma Studio.`
    ),
    error: "Failed to install Prisma Studio."
  },
  writeClientInLib: {
    found: "Skipping the creation of a lib/prisma.ts file that would hold a global instance of the Prisma Client because the prisma.ts file already exists in the lib folder.",
    success: "Global instance of Prisma Client created in lib/prisma.ts."
  },
  PRISMA_SETUP_SKIPPED_WARNING: chalk.yellow(
    `${chalk.bold("Warning")}: Nuxt Prisma Module setup skipped.
This may cause unexpected behavior.`
  ),
  skipMigrations: `
Not migrating the database.`,
  skipInstallingPrismaStudio: "Skipped installing Prisma Studio.",
  suggestions: {
    migrate: chalk.yellow(chalk.bold("\nHint: ")) + `You can manually run migrations by executing ${chalk.cyan.bold("npx prisma migrate dev")} or visit the ${chalk.blue.bold("Prisma Migrate")} docs for more info:
${chalk.underline.blue("https://pris.ly/nuxt/migrate")}. Or if you have pre-existing data on your database, you have to introspect it. Learn more in our docs:
${chalk.underline.blue("https://pris.ly/nuxt/dbpull")}.
`
  }
};

async function isPrismaCLIInstalled(directory) {
  try {
    await execa("npx", ["prisma", "version"], { cwd: directory });
    logSuccess(PREDEFINED_LOG_MESSAGES.isPrismaCLIinstalled.yes);
    return true;
  } catch (error) {
    logError(PREDEFINED_LOG_MESSAGES.isPrismaCLIinstalled.no);
    return false;
  }
}
async function installPrismaCLI(directory) {
  try {
    const installCmd = installingPrismaCLIWithPM();
    await execa(installCmd.pm, installCmd.command, {
      cwd: directory
    });
    logSuccess(PREDEFINED_LOG_MESSAGES.installPrismaCLI.yes);
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.installPrismaCLI.no);
    log(err);
  }
}
function checkIfPrismaSchemaExists(paths) {
  const exists = paths.reduce((prev, current) => {
    return existsSync(current) || prev;
  }, false);
  if (exists) {
    logSuccess(PREDEFINED_LOG_MESSAGES.checkIfPrismaSchemaExists.yes);
    return true;
  }
  logError(PREDEFINED_LOG_MESSAGES.checkIfPrismaSchemaExists.no);
  return false;
}
async function initPrisma({
  directory,
  provider = "sqlite",
  datasourceUrl
}) {
  const command = ["prisma", "init", "--datasource-provider"];
  command.push(provider);
  if (datasourceUrl) {
    command.push("--url");
    command.push(datasourceUrl);
  }
  try {
    log(PREDEFINED_LOG_MESSAGES.initPrisma.action);
    const { stdout: initializePrisma } = await execa("npx", command, {
      cwd: directory
    });
    log(initializePrisma?.split("Next steps")?.[0]);
    return true;
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.initPrisma.error);
    log(err);
    return false;
  }
}
function checkIfMigrationsFolderExists(path) {
  if (existsSync(path)) {
    logSuccess(PREDEFINED_LOG_MESSAGES.checkIfMigrationsFolderExists.success);
    return true;
  }
  logError(PREDEFINED_LOG_MESSAGES.checkIfMigrationsFolderExists.error);
  return false;
}
async function writeToSchema(prismaSchemaPath) {
  try {
    let existingSchema = "";
    try {
      existingSchema = readFileSync(prismaSchemaPath, "utf-8");
    } catch {
      logError(PREDEFINED_LOG_MESSAGES.writeToSchema.errorReadingFile);
      return false;
    }
    const addModel = `
            model User {
              id    Int     @id @default(autoincrement())
              email String  @unique
              name  String?
              posts Post[]
            }

            model Post {
              id        Int     @id @default(autoincrement())
              title     String
              content   String?
              published Boolean @default(false)
              author    User    @relation(fields: [authorId], references: [id])
              authorId  Int
            }
          `;
    const updatedSchema = `${existingSchema.trim()}

${addModel}`;
    writeFileSync(prismaSchemaPath, updatedSchema);
  } catch {
    logError(PREDEFINED_LOG_MESSAGES.writeToSchema.failedToWrite);
  }
}
async function runMigration(directory) {
  try {
    log(PREDEFINED_LOG_MESSAGES.runMigration.action);
    await execa("npx", ["prisma", "migrate", "dev", "--name", "init"], {
      cwd: directory
    });
    logSuccess(PREDEFINED_LOG_MESSAGES.runMigration.success);
    return true;
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.runMigration.error);
    log(err);
    log(PREDEFINED_LOG_MESSAGES.suggestions.migrate);
    return false;
  }
}
async function formatSchema(directory) {
  try {
    log(PREDEFINED_LOG_MESSAGES.formatSchema.action);
    await execa("npx", ["prisma", "format"], { cwd: directory });
  } catch {
    logError(PREDEFINED_LOG_MESSAGES.formatSchema.error);
  }
}
async function generateClient(directory, installPrismaClient = true) {
  log(PREDEFINED_LOG_MESSAGES.generatePrismaClient.action);
  if (installPrismaClient) {
    try {
      const installCmd = installingPrismaClientWithPM();
      await execa(installCmd.pm, installCmd.command, {
        cwd: directory
      });
    } catch (error) {
      logError(
        PREDEFINED_LOG_MESSAGES.generatePrismaClient.prismaClientInstallationError
      );
    }
  }
  try {
    const { stdout: generateClient2 } = await execa(
      "npx",
      ["prisma", "generate"],
      { cwd: directory }
    );
    log("\n" + generateClient2.split("\n").slice(0, 4).join("\n") + "\n");
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.generatePrismaClient.error);
  }
}
async function installStudio(directory) {
  try {
    log(PREDEFINED_LOG_MESSAGES.installStudio.action);
    const subprocess = execa("npx", ["prisma", "studio", "--browser", "none"], {
      cwd: directory
    });
    subprocess.unref();
    logSuccess(PREDEFINED_LOG_MESSAGES.installStudio.success);
    return true;
  } catch (err) {
    logError(PREDEFINED_LOG_MESSAGES.installStudio.error);
    log(err);
    return false;
  }
}
async function writeClientInLib(path) {
  const existingContent = existsSync(path);
  try {
    if (!existingContent) {
      const prismaClient = `import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

declare const globalThis: {
  prismaGlobal: ReturnType<typeof prismaClientSingleton>;
} & typeof global;

const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma
`;
      if (!existsSync("lib")) {
        mkdirSync("lib");
      }
      if (existsSync("lib/prisma.ts")) {
        log(PREDEFINED_LOG_MESSAGES.writeClientInLib.found);
        return;
      }
      writeFileSync("lib/prisma.ts", prismaClient);
      logSuccess(PREDEFINED_LOG_MESSAGES.writeClientInLib.success);
    }
  } catch (e) {
    log(e);
  }
}

const module = defineNuxtModule({
  meta: {
    name: "@prisma/nuxt",
    configKey: "prisma"
  },
  // Default configuration options of the Nuxt module
  defaults: {
    datasources: {
      db: {
        url: process.env.DATABASE_URL
      }
    },
    log: [],
    errorFormat: "pretty",
    writeToSchema: true,
    formatSchema: true,
    runMigration: true,
    installClient: true,
    installCLI: true,
    generateClient: true,
    installStudio: true,
    autoSetupPrisma: false,
    skipPrompts: false
  },
  async setup(options, nuxt) {
    const { resolve: resolveProject } = createResolver(nuxt.options.rootDir);
    const { resolve: resolver } = createResolver(import.meta.url);
    const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
    const npm_lifecycle_event = process.env?.npm_lifecycle_event;
    const skip_all_prompts = options.skipPrompts || npm_lifecycle_event === "dev:build";
    const prepareModule = () => {
      nuxt.options.experimental.componentIslands ||= {};
      nuxt.options.experimental.componentIslands = true;
      addPlugin(resolver("./runtime/plugin"));
      addImportsDir(resolver(runtimeDir, "composables"));
      addServerImportsDir(resolver(runtimeDir, "utils"));
      nuxt.options.vite.optimizeDeps = defu(
        nuxt.options.vite.optimizeDeps || {},
        {
          include: ["@prisma/nuxt > @prisma/client"]
        }
      );
    };
    const force_skip_prisma_setup = import.meta.env?.SKIP_PRISMA_SETUP ?? process.env?.SKIP_PRISMA_SETUP ?? false;
    nuxt.options.runtimeConfig.public.prisma = defu(
      nuxt.options.runtimeConfig.public.prisma || {},
      {
        log: options.log,
        errorFormat: options.errorFormat
      }
    );
    if (force_skip_prisma_setup || npm_lifecycle_event === "postinstall") {
      if (npm_lifecycle_event !== "postinstall") {
        log(PREDEFINED_LOG_MESSAGES.PRISMA_SETUP_SKIPPED_WARNING);
      }
      prepareModule();
      return;
    }
    const PROJECT_PATH = resolveProject();
    if (options.installCLI) {
      const prismaInstalled = await isPrismaCLIInstalled(PROJECT_PATH);
      if (!prismaInstalled) {
        await installPrismaCLI(PROJECT_PATH);
      }
    }
    const prismaSchemaExists = checkIfPrismaSchemaExists([
      resolveProject("prisma", "schema.prisma"),
      resolveProject("prisma", "schema")
    ]);
    const prismaMigrateWorkflow = async () => {
      const doesMigrationFolderExist = checkIfMigrationsFolderExists(
        resolveProject("prisma", "migrations")
      );
      if (doesMigrationFolderExist || !options.runMigration) {
        log(PREDEFINED_LOG_MESSAGES.skipMigrations);
        return;
      }
      const migrateAndFormatSchema = async () => {
        await runMigration(PROJECT_PATH);
        if (!options.formatSchema) {
          return;
        }
        await formatSchema(PROJECT_PATH);
      };
      if (options.autoSetupPrisma && options.runMigration) {
        await migrateAndFormatSchema();
        return;
      }
      const promptResult = await executeRequiredPrompts({
        promptForMigrate: !skip_all_prompts,
        promptForPrismaStudio: false
      });
      if (promptResult?.promptForPrismaMigrate && options.runMigration) {
        await migrateAndFormatSchema();
      }
      return;
    };
    const prismaInitWorkflow = async () => {
      await initPrisma({
        directory: PROJECT_PATH,
        provider: "sqlite"
      });
      await writeToSchema(resolveProject("prisma", "schema.prisma"));
      await prismaMigrateWorkflow();
    };
    const prismaStudioWorkflow = async () => {
      if (!options.installStudio || npm_lifecycle_event !== "dev") {
        log(PREDEFINED_LOG_MESSAGES.skipInstallingPrismaStudio);
        return;
      }
      const installAndStartPrismaStudio = async () => {
        await installStudio(PROJECT_PATH);
        nuxt.hooks.hook("devtools:customTabs", (tab) => {
          tab.push({
            name: "nuxt-prisma",
            title: "Prisma Studio",
            icon: "simple-icons:prisma",
            category: "server",
            view: {
              type: "iframe",
              src: "http://localhost:5555/",
              persistent: true
            }
          });
        });
      };
      if (options.autoSetupPrisma) {
        await installAndStartPrismaStudio();
        return;
      }
      await installAndStartPrismaStudio();
    };
    if (!prismaSchemaExists) {
      await prismaInitWorkflow();
    } else {
      await prismaMigrateWorkflow();
    }
    await writeClientInLib(resolveProject("lib", "prisma.ts"));
    if (options.generateClient) {
      await generateClient(PROJECT_PATH, options.installClient);
    }
    await prismaStudioWorkflow();
    prepareModule();
    return;
  }
});

export { module as default };
